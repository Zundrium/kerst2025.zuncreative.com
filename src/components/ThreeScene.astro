<script>
	//
	// GitHub van deze gsplat viewer
	// https://github.com/mkkellogg/GaussianSplats3D
	//
	import * as GaussianSplats3D from "@mkkellogg/gaussian-splats-3d";
	import * as THREE from "three";

	const viewer = new GaussianSplats3D.Viewer({
		cameraUp: [0, -1, 0],
		initialCameraPosition: [-40, -50, -40],
		initialCameraLookAt: [0, -15, 0],
		sharedMemoryForWorkers: false,
	});

	let isLoaded = false;
	let isUserInteracting = false;
	let angle = 0;
	const radius = 60; // Adjust as needed
	const center = new THREE.Vector3(0, -15, 0);

	viewer
		.addSplatScene(
			"/geom/scene.ksplat",
			{
				splatAlphaRemovalThreshold: 5,
				sceneRevealMode: GaussianSplats3D.SceneRevealMode.Instant,
				showLoadingUI: false, // Disable default UI
				sharedMemoryForWorkers: true,
				halfPrecisionCovariancesOnGPU: true,
				optimizeSplatData: true,
				sphericalHarmonicsDegree: 0,
				enableOptionalEffects: false,
				inMemoryCompressionLevel: 2,
				antialiased: false,
				sceneFadeInRateMultiplier: 1000000,
				position: [0, 1, 0],
				rotation: [0, 0, 0, 1],
				scale: [1.5, 1.5, 1.5],
			},
			(progress: any) => {
				// Dispatch progress event
				console.log("Scene progress:", progress);
				window.dispatchEvent(
					new CustomEvent("scene-progress", { detail: { progress } }),
				);
			},
			(error: any) => {
				// Dispatch error event
				window.dispatchEvent(
					new CustomEvent("scene-error", { detail: { error } }),
				);
			},
			() => {
				// Dispatch load event
				console.log("Scene loaded");
			},
		)
		.then(() => {
			viewer.start();
			isLoaded = true;

			setTimeout(() => {
				// Dispatch loaded event
				window.dispatchEvent(new Event("scene-loaded"));
			}, 3000);

			// Start rotation loop
			requestAnimationFrame(rotateCamera);
		});

	function rotateCamera() {
		if (!isLoaded || isUserInteracting) return; // Stop if user is interacting

		angle += 0.0; // Adjust speed

		// Calculate new position orbiting the y-axis (which seems to be Z or something else in this viewer based on cameraUp but let's try standard horizontal orbit)
		// The viewer uses cameraUp [0,-1,0], so Y is down?
		// Let's assume standard Y-up for calculation and adjust if needed, but given the config:
		// cameraUp: [0, -1, 0] suggests Y is inverted or it's a specific coordinate system.
		// initialCameraPosition: [-40, -50, -40]
		// initialCameraLookAt: [0, -15, 0]

		// If we want to orbit around [0, -15, 0] in the horizontal plane (X-Z usually), let's try that.

		const x = center.x + radius * Math.sin(angle);
		const z = center.z + radius * Math.cos(angle);
		const y = -50; // Keep height constant-ish

		viewer.camera.position.set(x, y, z);
		viewer.camera.lookAt(center);
		viewer.update(); // Trigger viewer update if required, though 'start()' loop handles rendering.
		// Actually viewer.camera gives access to the Three.js camera.
		// If the viewer has its own controls, they might fight.
		// GaussianSplats3D viewer usually uses OrbitControls. We might need to disable them or update them.

		requestAnimationFrame(rotateCamera);
	}

	// Stop rotation on user interaction
	window.addEventListener("mousedown", () => {
		isUserInteracting = true;
	});
	window.addEventListener("touchstart", () => {
		isUserInteracting = true;
	});
	window.addEventListener("wheel", () => {
		isUserInteracting = true;
	});
</script>
